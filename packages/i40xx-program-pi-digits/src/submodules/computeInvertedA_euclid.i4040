%include "memory.i4040"
%include "div16_fast.i4040"
%include "mul16.i4040"
%include "add16.i4040"
%include "sub16.i4040"

# INPUT:
#   STATUS_MEM_VARIABLE_MODULUS
#   STATUS_MEM_VARIABLE_A
# OUTPUT:
#   STATUS_MEM_VARIABLE_A_INV
# NOTES:
#   uses all registers in both banks
computeInvertedA:
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_A
  JMS loadVarFromStatusCharMemory                             # rr0..rr3 = A

  LD rr0
  DAC
  CMC
  JCN nz, computeInvertedA_nonTrivialA
  LD rr1
  JCN nz, computeInvertedA_nonTrivialA
  LD rr2
  JCN nz, computeInvertedA_nonTrivialA
  LD rr3
  JCN nz, computeInvertedA_nonTrivialA                        # if rr0..rr3 !== 1

computeInvertedA_trivialA:
  LDM $STATUS_MEM_VARIABLE_A_INV
  JMS storeVarToStatusCharMemory
  BBL 0                                                       # return 1

computeInvertedA_nonTrivialA:
  LDM $STATUS_MEM_VARIABLE_INV_R
  JMS storeVarToStatusCharMemory                              # r = rr0..rr3 (A)

  LDM $STATUS_MEM_VARIABLE_MODULUS
  JMS loadVarFromStatusCharMemory
  LDM $STATUS_MEM_VARIABLE_INV_PREV_R
  JMS storeVarToStatusCharMemory                              # prevR = m

  FIM r2, $STATUS_MEM_VARIABLE_A_INV . 0
  SRC r2
  WR1
  WR2
  WR3
  IAC
  WR0                                                         # A_inv = 1

  LDM 0xF
  WRM                                                         # sign = true

  LDM $STATUS_MEM_VARIABLE_INV_PREV_P
  JMS clearVarFromStatusCharMemory                            # prevP = 0

computeInvertedA_loop:
  FIM r4, $STATUS_MEM_VARIABLE_INV_R . $STATUS_MEM_VARIABLE_DIGIT_INV_PREV_R
  JMS div16x16                                                # [rr8, rr9, rr14, rr15; rr0..rr3] = prevR / r

  LD rr0
  DAC
  CMC
  JCN nz, computeInvertedA_loop_continue
  LD rr1
  JCN nz, computeInvertedA_loop_continue
  LD rr2
  JCN nz, computeInvertedA_loop_continue
  LD rr3
  JCN z, computeInvertedA_ret                                 # if rr0..rr3 (reminder) !== 1

computeInvertedA_loop_continue:
  FIM r2, $STATUS_MEM_VARIABLE_INV_R . 0
  SRC r2
  RD0
  XCH rr0
  WR0
  RD1
  XCH rr1
  WR1
  RD2
  XCH rr2
  WR2
  RD3
  XCH rr3
  WR3                                                         # rr0..rr3 <-> r

  LDM $STATUS_MEM_VARIABLE_INV_PREV_R
  JMS storeVarToStatusCharMemory                              # prevR = rr0..rr3 (tmp, previous value of r)

  JMS computeInvertedA_computeBezoutCoef

  LDM $STATUS_MEM_VARIABLE_A_INV
  JMS storeVarToStatusCharMemory                              # A_inv = rr0..rr3

  JUN computeInvertedA_loop

computeInvertedA_ret:
  JMS computeInvertedA_computeBezoutCoef

  FIM r4, $MAIN_MEM_VARIABLE_INV_P_SIGN . 0
  SRC r4
  RDM
  JCN nz, computeInvertedA_result_positive                     # if (sign)

  FIM r4, $STATUS_MEM_VARIABLE_MODULUS . 0
  SRC r4
  RD0
  XCH rr4
  RD1
  XCH rr5
  RD2
  XCH rr6
  RD3
  XCH rr7                                                     # rr4..rr7 = modulus

  JMS sub16x16                                                # rr0..rr3 = rr4..rr7 - rr0..rr3

computeInvertedA_result_positive:
  LDM $STATUS_MEM_VARIABLE_A_INV
  JMS storeVarToStatusCharMemory                              # A_inv = rr0..rr3
  BBL 0

computeInvertedA_computeBezoutCoef:
  # we are sure that accumulator is always zero here, so we set rr1 to 0 to select first main character in memory to update sign later
  XCH rr1
  LDM $STATUS_MEM_VARIABLE_A_INV
  JMS loadVarFromStatusCharMemory                             # rr0..rr3 = A_inv

  RDM
  CMA
  WRM                                                         # sign = !sign

  FIM r5, $STATUS_MEM_VARIABLE_INV_PREV_P . 0
  SRC r5
  RD0
  XCH rr4
  LD rr0
  WR0
  RD1
  XCH rr5
  LD rr1
  WR1
  RD2
  XCH rr6
  LD rr2
  WR2
  RD3
  XCH rr7
  LD rr3
  WR3                                                         # rr4..rr7 (tmp) = prevP, prevP = rr0..rr3 (A_inv)

  LD rr14
  ADD rr15
  JCN nz, computeInvertedA_computeBezoutCoef_swapFactors     # if (quotient[2] + quotient[3] > 0) => if (quotient > 256)
  JCN c, computeInvertedA_computeBezoutCoef_swapFactors

  LD rr8
  XCH rr10
  LD rr9
  XCH rr11                                                    # rr10..rr11 = quotient

computeInvertedA_computeBezoutCoef_cont:
  JMS mul16x8                                                 # [rr8, rr9, rr14, rr15] = rr0..rr3 * rr10..rr11 = A_inv * q
  JMS add_r2r3_r4r7                                           # rr0..rr3 = [rr8, rr9, rr14, rr15] + rr4..rr7 (tmp)
  BBL 0

computeInvertedA_computeBezoutCoef_swapFactors:
  LD rr0
  XCH rr10
  LD rr1
  XCH rr11                                                    # rr10..rr11 = A_inv

  LD rr8
  XCH rr0
  LD rr9
  XCH rr1
  LD rr14
  XCH rr2
  LD rr15
  XCH rr3                                                     # rr0..rr3 = quotient

  JUN computeInvertedA_computeBezoutCoef_cont
