%include "memory.i4040"
%include "mulMulti.i4040"
%include "div16_fast.i4040"
%include "mulMod_binary_fast.i4040"
%include "powerMod.i4040"
%include "addMod.i4040"
%include "computeInvertedA_euclid.i4040"

computeMaxVAndM:
  CLB
  XCH rr7
  LDM 0x09
  JMS loadVarFromMainMemory
  LDM 0x08
  # tmp = a
  JMS storeVarToMainMemory
computeMaxVAndM_loop:
  INC rr7
  LDM 0x08
  JMS loadVarFromMainMemory
  LDM 0x07
  JMS storeVarToMainMemory
  LDM 0x09
  XCH rr2
  LDM 0x07
  XCH rr4
  # tmp = tmp * a
  JMS mulMWxMW
  FIM r0, 0xB8
  # if 2 * N > tmp
  JMS compareVarsFromMainMemory
  JCN c, computeMaxVAndM_loop
  FIM r0, 0x60
  SRC r0
  LD rr7
  WR2
  BBL 0

# INPUT:
#   STATUS_MEM_VARIABLE_MODULUS
#   STATUS_MEM_VARIABLE_V
#   STATUS_MEM_VARIABLE_F_COMPUTATION_K
#   STATUS_MEM_VARIABLE_F_COMPUTATION_B
#   STATUS_MEM_VARIABLE_CURRENT_PRIME
# OUTPUT:
#   STATUS_MEM_VARIABLE_F_COMPUTATION_B
#   STATUS_MEM_VARIABLE_V
# VARIABLES:
#   STATUS_MEM_VARIABLE_B_COMPUTATION_COEF
updateB:
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_K
  JMS loadVarFromStatusCharMemory

  FIM r4, $STATUS_MEM_VARIABLE_CURRENT_PRIME . $STATUS_MEM_VARIABLE_DIGIT_B_COMPUTATION_COEF
  SRC r4
  RD0
  STC                                           # calculate a - k - 1 to have check (a - k <= 0), otherwise we need to test result for 0
  SUB rr0
  CMC
  RD1
  SUB rr1
  CMC
  RD2
  SUB rr2
  CMC
  RD3
  SUB rr3
  JCN nc, updateB_cont                          # if (a <= k)

  FIM r7, $STATUS_MEM_VARIABLE_F_COMPUTATION_K . $STATUS_MEM_VARIABLE_DIGIT_F_COMPUTATION_B
  JMS mulMod                                     # b = (b * k) % m
  BBL 0

updateB_cont:
  LDM $STATUS_MEM_VARIABLE_B_COMPUTATION_COEF
  JMS storeVarToStatusCharMemory                 # bCoef = k

updateB_loop:
  JMS div16x16                                   # bCoef / a

  LD rr0
  ADD rr1
  ADD rr2
  ADD rr3
  JCN c, updateB_return
  JCN nz, updateB_return                         # if bCoef % a !== 0

  FIM r2, $STATUS_MEM_VARIABLE_B_COMPUTATION_COEF . 0
  SRC r2
  LD rr8
  WR0
  LD rr9
  WR1
  LD rr14
  WR2
  LD rr15
  WR3                                            # bCoef = bCoef / a

  FIM r3, $STATUS_MEM_VARIABLE_V . 0
  SRC r3
  RD3
  DAC                                            # carry flag is set, but it's useful for (bCoef <= a) comparison instead of (bCoef < a)
  WR3                                            # v--

  FIM r3, $STATUS_MEM_VARIABLE_CURRENT_PRIME . $STATUS_MEM_VARIABLE_DIGIT_B_COMPUTATION_COEF
  SRC r3
  RD0
  SUB rr8
  CMC
  RD1
  SUB rr9
  CMC
  RD2
  SUB rr14
  CMC
  RD3
  SUB rr15
  FIM r4, $STATUS_MEM_VARIABLE_CURRENT_PRIME . $STATUS_MEM_VARIABLE_DIGIT_B_COMPUTATION_COEF
  JCN nc, updateB_loop                          # if (bCoef >= a)

updateB_return:
  FIM r7, $STATUS_MEM_VARIABLE_B_COMPUTATION_COEF . $STATUS_MEM_VARIABLE_DIGIT_F_COMPUTATION_B
  JMS mulMod                                     # b = (b * bCoef) % m
  BBL 0

# INPUT:
#   STATUS_MEM_VARIABLE_MODULUS
#   STATUS_MEM_VARIABLE_V
#   STATUS_MEM_VARIABLE_F_COMPUTATION_K
#   STATUS_MEM_VARIABLE_F_COMPUTATION_A
#   STATUS_MEM_VARIABLE_CURRENT_PRIME
# OUTPUT:
#   STATUS_MEM_VARIABLE_F_COMPUTATION_A
#   STATUS_MEM_VARIABLE_V
# VARIABLES:
#   STATUS_MEM_VARIABLE_A_COMPUTATION_COEF
updateA:
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_K
  JMS loadVarFromStatusCharMemory                        # rr0..rr3 = k

  LD rr0
  ADD rr0
  XCH rr0
  LD rr1
  ADD rr1
  XCH rr1
  LD rr2
  ADD rr2
  XCH rr2
  LD rr3
  ADD rr3
  XCH rr3                                                # rr0..rr3 = 2 * k

  FIM r2, $STATUS_MEM_VARIABLE_A_COMPUTATION_COEF . 0
  SRC r2
  LD rr0
  DAC
  CMC
  WR0
  XCH rr0
  LD rr1
  SUB rr5
  CMC
  WR1
  XCH rr1
  LD rr2
  SUB rr5
  CMC
  WR2
  XCH rr2
  LD rr3
  SUB rr5                                                # carry flag is set, but it's useful for (ACoef <= a) comparison instead of (ACoef < a)
  WR3
  XCH rr3                                                # ACoef = 2 * k - 1

  FIM r4, $STATUS_MEM_VARIABLE_CURRENT_PRIME . $STATUS_MEM_VARIABLE_DIGIT_A_COMPUTATION_COEF
  SRC r4
  RD0
  SUB rr0
  CMC
  RD1
  SUB rr1
  CMC
  RD2
  SUB rr2
  CMC
  RD3
  SUB rr3
  JCN c, updateA_return                                  # if (a > ACoef)
updateA_loop:
  JMS div16x16                                           # ACoef / a

  LD rr0
  ADD rr1
  ADD rr2
  ADD rr3
  JCN c, updateA_return
  JCN nz, updateA_return                                 # if ACoef % a !== 0

  FIM r2, $STATUS_MEM_VARIABLE_A_COMPUTATION_COEF . 0
  SRC r2
  LD rr8
  WR0
  LD rr9
  WR1
  LD rr14
  WR2
  LD rr15
  WR3                                                    # ACoef = ACoef / a

  FIM r3, $STATUS_MEM_VARIABLE_V . 0
  SRC r3
  RD3
  IAC
  WR3                                                    # v++

  FIM r3, $STATUS_MEM_VARIABLE_CURRENT_PRIME . $STATUS_MEM_VARIABLE_DIGIT_A_COMPUTATION_COEF
  SRC r3
  RD0
  STC                                                    # calculate a - ACoef - 1 to have check (a - ACoef <= 0), otherwise we need to test result for 0
  SUB rr8
  CMC
  RD1
  SUB rr9
  CMC
  RD2
  SUB rr14
  CMC
  RD3
  SUB rr15
  FIM r4, $STATUS_MEM_VARIABLE_CURRENT_PRIME . $STATUS_MEM_VARIABLE_DIGIT_A_COMPUTATION_COEF
  JCN nc, updateA_loop                                   # if (ACoef >= a)

updateA_return:
  FIM r7, $STATUS_MEM_VARIABLE_B_COMPUTATION_COEF . $STATUS_MEM_VARIABLE_DIGIT_F_COMPUTATION_A
  JMS mulMod                                             # A = (A * ACoef) % m
  BBL 0

# INPUT:
#   STATUS_MEM_VARIABLE_V
#   STATUS_MEM_VARIABLE_VMAX
#   STATUS_MEM_VARIABLE_F
#   STATUS_MEM_VARIABLE_F_COMPUTATION_A
#   STATUS_MEM_VARIABLE_F_COMPUTATION_B
#   STATUS_MEM_VARIABLE_F_COMPUTATION_K
#   STATUS_MEM_VARIABLE_CURRENT_PRIME
# OUTPUT:
#   STATUS_MEM_VARIABLE_F
updateF:
  FIM r2, $STATUS_MEM_VARIABLE_V . 0
  SRC r2
  RD3
  JCN z, updateF_ret                             # if (v === 0)

  XCH rr0
  RD2
  SUB rr0
  CLC
  XCH rr6                                        # rr6 = vmax - v

  JMS modularPowerForCurrentPrimeByExp           # fk = (a ^ (vmax - v)) mod m

  FIM r7, $STATUS_MEM_VARIABLE_F_COMPUTATION_B . $STATUS_MEM_VARIABLE_DIGIT_F_COMPUTATION_FK
  JMS mulMod                                     # fk = (fk * b) mod m

  FIM r7, $STATUS_MEM_VARIABLE_F_COMPUTATION_K . $STATUS_MEM_VARIABLE_DIGIT_F_COMPUTATION_FK
  JMS mulMod                                     # fk = (fk * k) mod m

  JMS computeInvertedA                           # A_inv = (A ^ (-1)) mod m

  FIM r7, $STATUS_MEM_VARIABLE_A_INV . $STATUS_MEM_VARIABLE_DIGIT_F_COMPUTATION_FK
  JMS mulMod                                     # fk = (fk * A_inv) mod m

  JMS addMod_fPlusFk                             # f = (f + fk) mod m

updateF_ret:
  BBL 0

# INPUT:
#   STATUS_MEM_VARIABLE_MODULUS
#   STATUS_MEM_VARIABLE_CURRENT_PRIME
#   STATUS_MEM_VARIABLE_N
#   STATUS_MEM_VARIABLE_VMAX
# OUTPUT:
#   STATUS_MEM_VARIABLE_F
# VARIABLES:
#   STATUS_MEM_VARIABLE_F_COMPUTATION_A
#   STATUS_MEM_VARIABLE_F_COMPUTATION_K
#   STATUS_MEM_VARIABLE_F_COMPUTATION_B
#   STATUS_MEM_VARIABLE_V
computeF:
  LDM $STATUS_MEM_VARIABLE_F
  JMS clearVarFromStatusCharMemory                    # f = 0

  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_A
  JMS clearVarFromStatusCharMemory
  LDM 0x1
  WR0                                                 # A = 1

  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_B
  JMS clearVarFromStatusCharMemory
  LDM 0x1
  WR0                                                 # b = 1

  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_K
  JMS clearVarFromStatusCharMemory
  LDM 0x1
  WR0                                                 # k = 1

  FIM r0, $STATUS_MEM_VARIABLE_V . 0
  SRC r0
  CLB
  WR3                                                 # v = 0

computeF_loop:
  CLC
  JMS updateB
  JMS updateA
  JMS updateF

  FIM r4, $STATUS_MEM_VARIABLE_N . 0
  FIM r1, $STATUS_MEM_VARIABLE_F_COMPUTATION_K . 1
  SRC r1
  RD0
  ADD rr3
  WR0
  XCH rr4
  RD1
  ADD rr9
  WR1
  XCH rr5
  RD2
  ADD rr9
  WR2
  XCH rr6
  RD3
  ADD rr9
  WR3
  XCH rr7                                             # rr4..rr7 = k = k + 1

  SRC r4
  RD0
  SUB rr4
  CMC
  RD1
  SUB rr5
  CMC
  RD2
  SUB rr6
  CMC
  RD3
  SUB rr7
  JCN c, computeF_loop                                # if rr4..rr7 <= N

  BBL 0
