%include "memory.i4040"
%include "mulMulti.i4040"
%include "divMulti.i4040"
%include "mulMod_binary_fast.i4040"
%include "powerMod.i4040"
%include "addMod.i4040"
%include "computeInvertedA_euclid.i4040"

computeMaxVAndM:
  CLB
  XCH rr7
  LDM 0x09
  JMS loadVarFromMainMemory
  LDM 0x08
  # tmp = a
  JMS storeVarToMainMemory
computeMaxVAndM_loop:
  INC rr7
  LDM 0x08
  JMS loadVarFromMainMemory
  LDM 0x07
  JMS storeVarToMainMemory
  LDM 0x09
  XCH rr2
  LDM 0x07
  XCH rr4
  # tmp = tmp * a
  JMS mulMWxMW
  FIM r0, 0xB8
  # if 2 * N > tmp
  JMS compareVarsFromMainMemory
  JCN c, computeMaxVAndM_loop
  FIM r0, 0x60
  SRC r0
  LD rr7
  WR2
  BBL 0

# INPUT:
#   STATUS_MEM_VARIABLE_MODULUS
#   STATUS_MEM_VARIABLE_V
#   STATUS_MEM_VARIABLE_F_COMPUTATION_K
#   STATUS_MEM_VARIABLE_F_COMPUTATION_B
#   MAIN_MEM_VARIABLE_DIV_DIVISOR
# OUTPUT:
#   STATUS_MEM_VARIABLE_F_COMPUTATION_B
#   STATUS_MEM_VARIABLE_V
# VARIABLES:
#   STATUS_MEM_VARIABLE_B_COMPUTATION_COEF
updateB:
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_K
  JMS loadVarFromStatusCharMemory
  LDM $STATUS_MEM_VARIABLE_B_COMPUTATION_COEF
  JMS storeVarToStatusCharMemory                 # bCoef = k

updateB_loop:
  LDM $MAIN_MEM_VARIABLE_DIV_DIVIDEND
  JMS storeVarToMainMemory
  JMS divMWxMW                                   # bCoef / a

  LDM $MAIN_MEM_VARIABLE_DIV_REMINDER
  JMS loadVarFromMainMemory
  LD rr0
  ADD rr1
  ADD rr2
  ADD rr3
  JCN c, updateB_return
  JCN nz, updateB_return                         # if bCoef % a !== 0

  LDM $MAIN_MEM_VARIABLE_DIV_QUOTIENT
  JMS loadVarFromMainMemory
  LDM $STATUS_MEM_VARIABLE_B_COMPUTATION_COEF
  JMS storeVarToStatusCharMemory                 # bCoef = bCoef / a

  FIM r3, $STATUS_MEM_VARIABLE_V . 0
  SRC r3
  RD3
  DAC
  WR3                                            # v--

  JUN updateB_loop

updateB_return:
  LDM $STATUS_MEM_VARIABLE_B_COMPUTATION_COEF
  XCH rr14
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_B
  XCH rr15
  JMS mulMod                                     # b = (b * bCoef) % m
  BBL 0

# INPUT:
#   STATUS_MEM_VARIABLE_MODULUS
#   STATUS_MEM_VARIABLE_V
#   STATUS_MEM_VARIABLE_F_COMPUTATION_K
#   STATUS_MEM_VARIABLE_F_COMPUTATION_A
#   MAIN_MEM_VARIABLE_DIV_DIVISOR
# OUTPUT:
#   STATUS_MEM_VARIABLE_F_COMPUTATION_A
#   STATUS_MEM_VARIABLE_V
# VARIABLES:
#   STATUS_MEM_VARIABLE_A_COMPUTATION_COEF
updateA:
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_K
  JMS loadVarFromStatusCharMemory                        # rr0..rr3 = k

  LD rr0
  ADD rr0
  XCH rr0
  LD rr1
  ADD rr1
  XCH rr1
  LD rr2
  ADD rr2
  XCH rr2
  LD rr3
  ADD rr3
  XCH rr3                                                # rr0..rr3 = 2 * k

  FIM r2, $STATUS_MEM_VARIABLE_A_COMPUTATION_COEF . 0
  SRC r2
  LD rr0
  DAC
  CMC
  WR0
  XCH rr0
  LD rr1
  SUB rr5
  CMC
  WR1
  XCH rr1
  LD rr2
  SUB rr5
  CMC
  WR2
  XCH rr2
  LD rr3
  SUB rr5
  WR3
  XCH rr3
  CLC                                                    # rr0..rr3 = ACoef = 2 * k - 1

updateA_loop:
  LDM $MAIN_MEM_VARIABLE_DIV_DIVIDEND
  JMS storeVarToMainMemory
  JMS divMWxMW                                           # ACoef / a

  LDM $MAIN_MEM_VARIABLE_DIV_REMINDER
  JMS loadVarFromMainMemory
  LD rr0
  ADD rr1
  ADD rr2
  ADD rr3
  JCN c, updateA_return
  JCN nz, updateA_return                                 # if ACoef % a !== 0

  LDM $MAIN_MEM_VARIABLE_DIV_QUOTIENT
  JMS loadVarFromMainMemory
  LDM $STATUS_MEM_VARIABLE_A_COMPUTATION_COEF
  JMS storeVarToStatusCharMemory                         # ACoef = ACoef / a

  FIM r3, $STATUS_MEM_VARIABLE_V . 0
  SRC r3
  RD3
  IAC
  WR3                                                    # v++

  JUN updateA_loop

updateA_return:
  LDM $STATUS_MEM_VARIABLE_A_COMPUTATION_COEF
  XCH rr14
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_A
  XCH rr15
  JMS mulMod                                             # A = (A * ACoef) % m
  BBL 0

# INPUT:
#   STATUS_MEM_VARIABLE_V
#   STATUS_MEM_VARIABLE_VMAX
#   STATUS_MEM_VARIABLE_F
#   STATUS_MEM_VARIABLE_F_COMPUTATION_A
#   STATUS_MEM_VARIABLE_F_COMPUTATION_B
#   STATUS_MEM_VARIABLE_F_COMPUTATION_K
#   STATUS_MEM_VARIABLE_CURRENT_PRIME
#   MAIN_MEM_VARIABLE_DIV_DIVISOR
# OUTPUT:
#   STATUS_MEM_VARIABLE_F
updateF:
  FIM r2, $STATUS_MEM_VARIABLE_V . 0
  SRC r2
  RD3
  JCN z, updateF_ret                             # if (v === 0)

  XCH rr0
  RD2
  SUB rr0
  CLC
  XCH rr6                                        # rr6 = vmax - v

  JMS modularPowerForCurrentPrimeByExp           # fk = (a ^ (vmax - v)) mod m

  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_B
  XCH rr14
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_FK
  XCH rr15
  JMS mulMod                                     # fk = (fk * b) mod m

  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_K
  XCH rr14
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_FK
  XCH rr15
  JMS mulMod                                     # fk = (fk * k) mod m

  JMS computeInvertedA                           # A_inv = (A ^ (-1)) mod m

  LDM $STATUS_MEM_VARIABLE_A_INV
  XCH rr14
  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_FK
  XCH rr15
  JMS mulMod                                     # fk = (fk * A_inv) mod m

  JMS addMod_fPlusFk                             # f = (f + fk) mod m

updateF_ret:
  BBL 0

# INPUT:
#   STATUS_MEM_VARIABLE_MODULUS
#   STATUS_MEM_VARIABLE_CURRENT_PRIME
#   STATUS_MEM_VARIABLE_N
#   STATUS_MEM_VARIABLE_VMAX
# OUTPUT:
#   STATUS_MEM_VARIABLE_F
# VARIABLES:
#   STATUS_MEM_VARIABLE_F_COMPUTATION_A
#   STATUS_MEM_VARIABLE_F_COMPUTATION_K
#   STATUS_MEM_VARIABLE_F_COMPUTATION_B
#   STATUS_MEM_VARIABLE_V
computeF:
  LDM $STATUS_MEM_VARIABLE_F
  JMS clearVarFromStatusCharMemory                    # f = 0

  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_A
  JMS clearVarFromStatusCharMemory
  LDM 0x1
  WR0                                                 # A = 1

  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_B
  JMS clearVarFromStatusCharMemory
  LDM 0x1
  WR0                                                 # b = 1

  LDM $STATUS_MEM_VARIABLE_F_COMPUTATION_K
  JMS clearVarFromStatusCharMemory
  LDM 0x1
  WR0                                                 # k = 1

  FIM r0, $STATUS_MEM_VARIABLE_V . 0
  SRC r0
  CLB
  WR3                                                 # v = 0

computeF_loop:
  JMS updateB
  JMS updateA
  JMS updateF

  FIM r4, $STATUS_MEM_VARIABLE_N . 0
  FIM r1, $STATUS_MEM_VARIABLE_F_COMPUTATION_K . 1
  SRC r1
  RD0
  ADD rr3
  WR0
  XCH rr4
  RD1
  ADD rr9
  WR1
  XCH rr5
  RD2
  ADD rr9
  WR2
  XCH rr6
  RD3
  ADD rr9
  WR3
  XCH rr7                                             # rr4..rr7 = k = k + 1

  SRC r4
  RD0
  SUB rr4
  CMC
  RD1
  SUB rr5
  CMC
  RD2
  SUB rr6
  CMC
  RD3
  SUB rr7
  JCN c, computeF_loop                                # if rr4..rr7 <= N

  BBL 0
